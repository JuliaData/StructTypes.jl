<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · StructTypes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">StructTypes.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#StructTypes.StructType"><span><code>StructTypes.StructType</code></span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/StructTypes.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="StructTypes.jl"><a class="docs-heading-anchor" href="#StructTypes.jl">StructTypes.jl</a><a id="StructTypes.jl-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.jl" title="Permalink"></a></h1><p>This guide provides documentation around the <code>StructTypes.StructType</code> trait for Julia objects and its associated functions. This package was born from a desire to make working with, and especially constructing, Julia objects more programmatic and customizable. This allows powerful workflows when doing generic object transformations and serialization.</p><p>If anything isn&#39;t clear or you find bugs, don&#39;t hesitate to <a href="https://github.com/JuliaData/StructTypes.jl/issues/new">open a new issue</a>, even just for a question, or come chat with us on the <a href="https://julialang.slack.com/messages/data/">#data</a> slack channel with questions, concerns, or clarifications.</p><ul><li><a href="#StructTypes.jl">StructTypes.jl</a></li><ul><li><a href="#StructTypes.StructType"><code>StructTypes.StructType</code></a></li><ul><li><a href="#DataTypes">DataTypes</a></li><li><a href="#Interface-Types">Interface Types</a></li><li><a href="#CustomStruct">CustomStruct</a></li><li><a href="#AbstractTypes">AbstractTypes</a></li><li><a href="#Utilities">Utilities</a></li></ul></ul></ul><h2 id="StructTypes.StructType"><a class="docs-heading-anchor" href="#StructTypes.StructType"><code>StructTypes.StructType</code></a><a id="StructTypes.StructType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.StructType" title="Permalink"></a></h2><p>In general, custom Julia types tend to be one of: 1) &quot;data types&quot;, 2) &quot;interface types&quot; or sometimes 3) &quot;custom types&quot; or 4) &quot;abstract types&quot; with a known set of concrete subtypes. Data types tend to be &quot;collection of fields&quot; kind of types; fields are generally public and directly accessible, they might also be made to model &quot;objects&quot; in the object-oriented sense. In any case, the type is &quot;nominal&quot; in the sense that it&#39;s &quot;made up&quot; of the fields it has, sometimes even if just for making it more convenient to pass them around together in functions.</p><p>Interface types, on the other hand, are characterized by <strong>private</strong> fields; they contain optimized representations &quot;under the hood&quot; to provide various features/functionality and are useful via interface methods implemented: iteration, <code>getindex</code>, accessor methods, etc. Many package-provided libraries or Base-provided structures are like this: <code>Dict</code>, <code>Array</code>, <code>Socket</code>, etc. For these types, their underlying fields are mostly cryptic and provide little value to users directly, and are often explictly documented as being implementation details and not to be relied upon directly under warning of breakage.</p><p>What does all this have to do with the <code>StructTypes.StructType</code> trait? A lot! There&#39;s often a desire to programmatically access the &quot;public&quot; names and values of an object, whether it&#39;s a data, interface, custom or abstract type. For data types, this means each direct field name and value. For interface types, this means having an API to get the names and values (<em>ignoring</em> direct fields). Similarly for programmatic <em>construction</em>, we need to specify how to construct the Julia structure given an arbitrary set of key-value pairs.</p><p>For &quot;custom&quot; types, this is kind of a catchall for those types that don&#39;t really fit in the &quot;data&quot; or &quot;interface&quot; buckets; like wrapper types. You don&#39;t really care about the wrapper type itself but about the type it wraps with a few modifications.</p><p>For abstract types, it can be useful to &quot;bundle&quot; the behavior of concrete subtypes under a single abstract type; and when serializing/deserializing, an extra key-value pair is added to encode the true concrete type.</p><p>Each of these 4 kinds of struct type categories will be now be detailed.</p><h3 id="DataTypes"><a class="docs-heading-anchor" href="#DataTypes">DataTypes</a><a id="DataTypes-1"></a><a class="docs-heading-anchor-permalink" href="#DataTypes" title="Permalink"></a></h3><p>You&#39;ll remember that &quot;data types&quot; are Julia structs that are &quot;made up&quot; of their fields. In the object-oriented world, this would be characterized by marking a field as <code>public</code>. A quick example is:</p><pre><code class="language-julia">struct Vehicle
    make::String
    model::String
    year::Int
end</code></pre><p>In this case, our <code>Vehicle</code> type is entirely &quot;made up&quot; by its fields, <code>make</code>, <code>model</code>, and <code>year</code>.</p><p>There are three ways to define the <code>StructTypes.StructType</code> of these kinds of objects:</p><pre><code class="language-julia">StructTypes.StructType(::Type{MyType}) = StructTypes.Struct() # an alias for StructTypes.UnorderedStruct()
# or
StructTypes.StructType(::Type{MyType}) = StructTypes.Mutable()
# or
StructTypes.StructType(::Type{MyType}) = StructTypes.OrderedStruct()</code></pre><h4 id="StructTypes.Struct"><a class="docs-heading-anchor" href="#StructTypes.Struct"><code>StructTypes.Struct</code></a><a id="StructTypes.Struct-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.Struct" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StructTypes.Struct" href="#StructTypes.Struct"><code>StructTypes.Struct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.Struct()
StructTypes.StructType(::Type{T}) = StructTypes.UnorderedStruct()
StructTypes.StructType(::Type{T}) = StructTypes.OrderedStruct()</code></pre><p>Signal that <code>T</code> is an immutable type who&#39;s fields should be used directly when serializing/deserializing. If a type is defined as <code>StructTypes.Struct</code>, it defaults to <code>StructTypes.UnorderedStruct</code>, which means its fields are allowed to be serialized/deserialized in any order, as opposed to <code>StructTypes.OrderedStruct</code> which signals that serialization/deserialization <em>must</em> occur in its defined field order exclusively. This can enable optimizations when an order can be guaranteed, but care must be taken to ensure any serialization formats can properly guarantee the order (for example, the JSON specification doesn&#39;t explicitly require ordered fields for &quot;objects&quot;, though most implementations have a way to support this). For example, when deserializing a <code>Struct.OrderedStruct</code>, parsed input fields are passed directly, in input order to the <code>T</code> constructor, like <code>T(field1, field2, field3)</code>. This means that field names may be ignored when deserializing; fields are directly passed to <code>T</code> in the order they&#39;re encountered.</p><p>Another example, for reading a <code>StructTypes.OrderedStruct()</code> from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like <code>T(val1, val2, val3)</code>. Yes, the JSON specification says that Objects are specifically <strong>un-ordered</strong> collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the &quot;trusting&quot; that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of <code>StructTypes.OrderedStruct()</code> in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren&#39;t anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the <code>StructTypes.UnorderedStruct</code> or <code>StructTypes.Mutable()</code> options.</p><pre><code class="language-">struct CoolType
    val1::Int
    val2::Int
    val3::String
end

StructTypes.StructType(::Type{CoolType}) = StructTypes.OrderedStruct()

# JSON3 package as example
@assert JSON3.read(&quot;{&quot;val1&quot;: 1, &quot;val2&quot;: 2, &quot;val3&quot;: 3}&quot;, CoolType) == CoolType(1, 2, &quot;3&quot;)
# note how `val2` field is first, then `val1`, but fields are passed *in-order* to `CoolType` constructor; BE CAREFUL!
@assert JSON3.read(&quot;{&quot;val2&quot;: 2, &quot;val1&quot;: 1, &quot;val3&quot;: 3}&quot;, CoolType) == CoolType(2, 1, &quot;3&quot;)
# if we instead define `Struct`, which defaults to `StructTypes.UnorderedStruct`, then the above example works
StructTypes.StructType(::Type{CoolType}) = StructTypes.Struct()
@assert JSON3.read(&quot;{&quot;val2&quot;: 2, &quot;val1&quot;: 1, &quot;val3&quot;: 3}&quot;, CoolType) == CoolType(1, 2, &quot;3&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL57-L96">source</a></section></article><h4 id="StructTypes.Mutable"><a class="docs-heading-anchor" href="#StructTypes.Mutable"><code>StructTypes.Mutable</code></a><a id="StructTypes.Mutable-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.Mutable" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StructTypes.Mutable" href="#StructTypes.Mutable"><code>StructTypes.Mutable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.Mutable()</code></pre><p>Signal that <code>T</code> is a mutable struct with an empty constructor for serializing/deserializing. Though slightly less performant than <code>StructTypes.Struct</code>, <code>Mutable</code> is a much more robust method for mapping Julia struct fields for serialization. This technique requires your Julia type to be defined, <strong>at a minimum</strong>, like:</p><pre><code class="language-julia">mutable struct T
    field1
    field2
    field3
    # etc.

    T() = new()
end</code></pre><p>Note specifically that we&#39;re defining a <code>mutable struct</code> to allow field mutation, and providing a <code>T() = new()</code> inner constructor which constructs an &quot;empty&quot; <code>T</code> where <code>isbitstype</code> fields will be randomly initialized, and reference fields will be <code>#undef</code>. (Note that the inner constructor doesn&#39;t need to be <strong>exactly</strong> this, but at least needs to be callable like <code>T()</code>. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like <code>T()</code>, then serialization will take each key-value input pair, setting the field as the key is encountered, and converting the value to the appropriate field value. This flow has the nice properties of: allowing object construction success even if fields are missing in the input, and if &quot;extra&quot; fields exist in the input that aren&#39;t apart of the Julia struct&#39;s fields, they will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary data foramts that may be generated via web services, databases, other language libraries, etc.</p><p>There are a few additional helper methods that can be utilized by <code>StructTypes.Mutable()</code> types to hand-tune field reading/writing behavior:</p><ul><li><p><code>StructTypes.names(::Type{T}) = ((:juliafield1, :serializedfield1), (:juliafield2, :serializedfield2))</code>: provides a mapping of Julia field name to expected serialized object key name. This affects both serializing and deserializing. When deserializing the <code>serializedfield1</code> key, the <code>juliafield1</code> field of <code>T</code> will be set. When serializing the <code>juliafield2</code> field of <code>T</code>, the output key will be <code>serializedfield2</code>. Field name mappings are provided as a <code>Tuple</code> of <code>Tuple{Symbol, Symbol}</code>s, i.e. each field mapping is a Julia field name <code>Symbol</code> (first) and serialized field name <code>Symbol</code> (second).</p></li><li><p><code>StructTypes.excludes(::Type{T}) = (:field1, :field2)</code>: specify fields of <code>T</code> to ignore when serializing and deserializing, provided as a <code>Tuple</code> of <code>Symbol</code>s. When deserializing, if <code>field1</code> is encountered as an input key, it&#39;s value will be read, but the field will not be set in <code>T</code>. When serializing, <code>field1</code> will be skipped when serializing out <code>T</code> fields as key-value pairs.</p></li><li><p><code>StructTypes.omitempties(::Type{T}) = (:field1, :field2)</code>: specify fields of <code>T</code> that shouldn&#39;t be serialized if they are &quot;empty&quot;, provided as a <code>Tuple</code> of <code>Symbol</code>s. This only affects serializing. If a field is a collection (AbstractDict, AbstractArray, etc.) and <code>isempty(x) === true</code>, then it will not be serialized. If a field is <code>#undef</code>, it will not be serialized. If a field is <code>nothing</code>, it will not be serialized. To apply this to all fields of <code>T</code>, set <code>StructTypes.omitempties(::Type{T}) = true</code>. You can customize this behavior. For example, by default, <code>missing</code> is not considered to be &quot;empty&quot;. If you want <code>missing</code> to be considered &quot;empty&quot; when serializing your type <code>MyType</code>, simply define:</p></li></ul><pre><code class="language-julia">@inline StructTypes.isempty(::Type{T}, ::Missing) where {T &lt;: MyType} = true</code></pre><ul><li><code>StructTypes.keywordargs(::Type{T}) = (field1=(dateformat=dateformat&quot;mm/dd/yyyy&quot;,), field2=(dateformat=dateformat&quot;HH MM SS&quot;,))</code>: provide keyword arguments for fields of type <code>T</code> that should be passed to functions that set values for this field. Define <code>StructTypes.keywordargs</code> as a NamedTuple of NamedTuples.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL108-L136">source</a></section></article><h4 id="StructTypes.OrderedStruct"><a class="docs-heading-anchor" href="#StructTypes.OrderedStruct"><code>StructTypes.OrderedStruct</code></a><a id="StructTypes.OrderedStruct-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.OrderedStruct" title="Permalink"></a></h4><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>StructTypes.OrderedStruct</code>. Check Documenter&#39;s build log for details.</p></div></div><p>Support functions for <code>StructTypes.DataType</code>s:</p><article class="docstring"><header><a class="docstring-binding" id="StructTypes.names" href="#StructTypes.names"><code>StructTypes.names</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.names(::Type{T}) = ((:juliafield1, :serializedfield1), (:juliafield2, :serializedfield2))</code></pre><p>Provides a mapping of Julia field name to expected serialized object key name. This affects both reading and writing. When reading the <code>serializedfield1</code> key, the <code>juliafield1</code> field of <code>T</code> will be set. When writing the <code>juliafield2</code> field of <code>T</code>, the output key will be <code>serializedfield2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.excludes" href="#StructTypes.excludes"><code>StructTypes.excludes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.excludes(::Type{T}) = (:field1, :field2)</code></pre><p>Specify for a <code>StructTypes.Mutable</code> <code>StructType</code> the fields, given as a <code>Tuple</code> of <code>Symbol</code>s, that should be ignored when deserializing, and excluded from serializing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.omitempties" href="#StructTypes.omitempties"><code>StructTypes.omitempties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.omitempties(::Type{T}) = (:field1, :field2)
StructTypes.omitempties(::Type{T}) = true</code></pre><p>Specify for a <code>StructTypes.Mutable</code> <code>StructType</code> the fields, given as a <code>Tuple</code> of <code>Symbol</code>s, that should not be serialized if they&#39;re considered &quot;empty&quot;.</p><p>If a field is a collection (AbstractDict, AbstractArray, etc.) and <code>isempty(x) === true</code>, then it will not be serialized. If a field is <code>#undef</code>, it will not be serialized. If a field is <code>nothing</code>, it will not be serialized. To apply this to all fields of <code>T</code>, set <code>StructTypes.omitempties(::Type{T}) = true</code>. You can customize this behavior. For example, by default, <code>missing</code> is not considered to be &quot;empty&quot;. If you want <code>missing</code> to be considered &quot;empty&quot; when serializing your type <code>MyType</code>, simply define:</p><pre><code class="language-julia">@inline StructTypes.isempty(::Type{T}, ::Missing) where {T &lt;: MyType} = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL180-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.keywordargs" href="#StructTypes.keywordargs"><code>StructTypes.keywordargs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.keywordargs(::Type{MyType}) = (field1=(dateformat=dateformat&quot;mm/dd/yyyy&quot;,), field2=(dateformat=dateformat&quot;HH MM SS&quot;,))</code></pre><p>Specify for a <code>StructTypes.Mutable</code> the keyword arguments by field, given as a <code>NamedTuple</code> of <code>NamedTuple</code>s, that should be passed to the <code>StructTypes.construct</code> method when deserializing <code>MyType</code>. This essentially allows defining specific keyword arguments you&#39;d like to be passed for each field in your struct. Note that keyword arguments can be passed when reading, like <code>JSON3.read(source, MyType; dateformat=...)</code> and they will be passed down to each <code>StructTypes.construct</code> method. <code>StructTypes.keywordargs</code> just allows the defining of specific keyword arguments per field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL206-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.idproperty" href="#StructTypes.idproperty"><code>StructTypes.idproperty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.idproperty(::Type{MyType}) = :id</code></pre><p>Specify which field of a type uniquely identifies it. The unique identifier field name is given as a Symbol. Useful in database applications where the id field can be used to distinguish separate objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL219-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.fieldprefix" href="#StructTypes.fieldprefix"><code>StructTypes.fieldprefix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.fieldprefix(::Type{MyType}, field::Symbol) = :field_</code></pre><p>When interacting with database tables and other strictly 2D data formats, objects with aggregate fields must be flattened into a single set of column names. When deserializing a set of columns into an object with aggregate fields, a field type&#39;s <code>fieldprefix</code> signals that column names beginning with, in the example above, <code>:field_</code>, should be collected together when constructing the <code>field</code> field of <code>MyType</code>. Note the default definition is <code>StructTypes.fieldprefix(T, nm) = Symbol(nm, :_)</code>.</p><p>Here&#39;s a more concrete, albeit contrived, example:</p><pre><code class="language-julia">struct Spouse
    id::Int
    name::String
end

StructTypes.StructType(::Type{Spouse}) = StructTypes.Struct()

struct Person
    id::Int
    name::String
    spouse::Person
end

StructTypes.StructType(::Type{Person}) = StructTypes.Struct()
StructTypes.fieldprefix(::Type{Person}, field::Symbol) = field == :spouse ? :spouse_ : :_</code></pre><p>Here we have two structs, <code>Spouse</code> and <code>Person</code>, and a <code>Person</code> has a <code>spouse::Spouse</code>. The database tables to represent these entities might look like:</p><pre><code class="language-SQL">CREATE TABLE spouse (id INT, name VARCHAR);
CREATE TABLE person (id INT, name VARCHAR, spouse_id INT);</code></pre><p>If we want to leverage a package like Strapping.jl to automatically handle the object construction for us, we could write a get query like the following to ensure a full <code>Person</code> with field <code>spouse::Spouse</code> can be constructed:</p><pre><code class="language-julia">getPerson(id::Int) = Strapping.construct(Person, DBInterface.execute(db,
    &quot;&quot;&quot;
        SELECT person.id as id, person.name as name, spouse.id as spouse_id, spouse.name as spouse_name
        FROM person
        LEFT JOIN spouse ON person.spouse_id = spouse.id
        WHERE person.id = $id
    &quot;&quot;&quot;))</code></pre><p>This works because the column names in the resultset of this query are &quot;id, name, spouse<em>id, spouse</em>name&quot;; because we defined <code>StructTypes.fieldprefix</code> for <code>Person</code>, Strapping.jl knows that each column starting with &quot;spouse_&quot; should be used in constructing the <code>Spouse</code> field of <code>Person</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL230-L278">source</a></section></article><h3 id="Interface-Types"><a class="docs-heading-anchor" href="#Interface-Types">Interface Types</a><a id="Interface-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-Types" title="Permalink"></a></h3><p>For interface types, we don&#39;t want the internal fields of a type exposed, so an alternative API is to define the closest &quot;basic&quot; type that our custom type should map to. This is done by choosing one of the following definitions:</p><pre><code class="language-julia">StructTypes.StructType(::Type{MyType}) = StructTypes.DictType()
StructTypes.StructType(::Type{MyType}) = StructTypes.ArrayType()
StructTypes.StructType(::Type{MyType}) = StructTypes.StringType()
StructTypes.StructType(::Type{MyType}) = StructTypes.NumberType()
StructTypes.StructType(::Type{MyType}) = StructTypes.BoolType()
StructTypes.StructType(::Type{MyType}) = StructTypes.NullType()</code></pre><p>Now we&#39;ll walk through each of these and what it means to map my custom Julia type to an interface type.</p><h4 id="StructTypes.DictType"><a class="docs-heading-anchor" href="#StructTypes.DictType"><code>StructTypes.DictType</code></a><a id="StructTypes.DictType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.DictType" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StructTypes.DictType" href="#StructTypes.DictType"><code>StructTypes.DictType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.DictType()</code></pre><p>Declare that <code>T</code> should map to a dict-like object of unordered key-value pairs, where keys are <code>Symbol</code>, <code>String</code>, or <code>Int64</code>, and values are any other type (or <code>Any</code>).</p><p>Types already declared as <code>StructTypes.DictType()</code> include:</p><ul><li>Any subtype of <code>AbstractDict</code></li><li>Any <code>NamedTuple</code> type</li><li>The <code>Pair</code> type</li></ul><p>So if your type subtypes <code>AbstractDict</code> and implements its interface, then it will inherit the <code>DictType</code> definition and serializing/deserializing should work automatically.</p><p>Otherwise, the interface to satisfy <code>StructTypes.DictType()</code> for deserializing is:</p><ul><li><code>T(x::Dict{Symbol, Any})</code>: implement a constructor that takes a <code>Dict{Symbol, Any}</code> of input key-value pairs</li><li><code>StructTypes.construct(::Type{T}, x::Dict; kw...)</code>: alternatively, you may overload the <code>StructTypes.construct</code> method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)</li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>pairs(x)</code>: implement the <code>pairs</code> iteration function (from Base) to iterate key-value pairs to be serialized</li><li><code>StructTypes.keyvaluepairs(x::T)</code>: alternatively, you can overload the <code>StructTypes.keyvaluepairs</code> function if overloading <code>pairs</code> isn&#39;t possible for whatever reason</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL305-L326">source</a></section></article><h4 id="StructTypes.ArrayType"><a class="docs-heading-anchor" href="#StructTypes.ArrayType"><code>StructTypes.ArrayType</code></a><a id="StructTypes.ArrayType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.ArrayType" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StructTypes.ArrayType" href="#StructTypes.ArrayType"><code>StructTypes.ArrayType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.ArrayType()</code></pre><p>Declare that <code>T</code> should map to an array of ordered elements, homogenous or otherwise.</p><p>Types already declared as <code>StructTypes.ArrayType()</code> include:</p><ul><li>Any subtype of <code>AbstractArray</code></li><li>Any subtype of <code>AbstractSet</code></li><li>Any <code>Tuple</code> type</li></ul><p>So if your type already subtypes these and satifies their interface, things should just work.</p><p>Otherwise, the interface to satisfy <code>StructTypes.ArrayType()</code> for deserializing is:</p><ul><li><code>T(x::Vector)</code>: implement a constructor that takes a <code>Vector</code> argument of values and constructs a <code>T</code></li><li><code>StructTypes.construct(::Type{T}, x::Vecto; kw...)</code>: alternatively, you may overload the <code>StructTypes.construct</code> method for your type if defining a constructor isn&#39;t possible</li><li>Optional: <code>Base.IteratorEltype(::Type{T}) = Base.HasEltype()</code> and <code>Base.eltype(x::T)</code>: this can be used to signal that elements for your type are expected to be a homogenous type</li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>iterate(x::T)</code>: just iteration over each element is required; note if you subtype <code>AbstractArray</code> and define <code>getindex(x::T, i::Int)</code>, then iteration is inherited for your type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL341-L362">source</a></section></article><h4 id="StructTypes.StringType"><a class="docs-heading-anchor" href="#StructTypes.StringType"><code>StructTypes.StringType</code></a><a id="StructTypes.StringType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.StringType" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StructTypes.StringType" href="#StructTypes.StringType"><code>StructTypes.StringType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.StringType()</code></pre><p>Declare that <code>T</code> should map to a string value.</p><p>Types already declared as <code>StructTypes.StringType()</code> include:</p><ul><li>Any subtype of <code>AbstractString</code></li><li>The <code>Symbol</code> type</li><li>Any subtype of <code>Enum</code> (values are written with their symbolic name)</li><li>Any subtype of <code>AbstractChar</code></li><li>The <code>UUID</code> type</li><li>Any <code>Dates.TimeType</code> subtype (<code>Date</code>, <code>DateTime</code>, <code>Time</code>, etc.)</li></ul><p>So if your type is an <code>AbstractString</code> or <code>Enum</code>, then things should already work.</p><p>Otherwise, the interface to satisfy <code>StructTypes.StringType()</code> for deserializing is:</p><ul><li><code>T(x::String)</code>: define a constructor for your type that takes a single String argument</li><li><code>StructTypes.construct(::Type{T}, x::String; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code> for your type</li><li><code>StructTypes.construct(::Type{T}, ptr::Ptr{UInt8}, len::Int; kw...)</code>: another option is to overload <code>StructTypes.construct</code> with pointer and length arguments, if it&#39;s possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both <code>StructTypes.construct</code> methods, since direct pointer/length deserialization may not be possible for some inputs</li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>Base.string(x::T)</code>: overload <code>Base.string</code> for your type to return a &quot;stringified&quot; value, or more specifically, that returns an <code>AbstractString</code>, and should implement <code>ncodeunits(x)</code> and <code>codeunit(x, i)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL369-L393">source</a></section></article><h4 id="StructTypes.NumberType"><a class="docs-heading-anchor" href="#StructTypes.NumberType"><code>StructTypes.NumberType</code></a><a id="StructTypes.NumberType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.NumberType" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StructTypes.NumberType" href="#StructTypes.NumberType"><code>StructTypes.NumberType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.NumberType()</code></pre><p>Declare that <code>T</code> should map to a number value.</p><p>Types already declared as <code>StructTypes.NumberType()</code> include:</p><ul><li>Any subtype of <code>Signed</code></li><li>Any subtype of <code>Unsigned</code></li><li>Any subtype of <code>AbstractFloat</code></li></ul><p>In addition to declaring <code>StructTypes.NumberType()</code>, custom types can also specify a specific, <strong>existing</strong> number type it should map to. It does this like:</p><pre><code class="language-julia">StructTypes.numbertype(::Type{T}) = Float64</code></pre><p>In this case, <code>T</code> declares it should map to an already-supported number type: <code>Float64</code>. This means that when deserializing, an input will be parsed/read/deserialiezd as a <code>Float64</code> value, and then call <code>T(x::Float64)</code>. Note that custom types may also overload <code>StructTypes.construct(::Type{T}, x::Float64; kw...)</code> if using a constructor isn&#39;t possible. Also note that the default for any type declared as <code>StructTypes.NumberType()</code> is <code>Float64</code>.</p><p>Similarly for serializing, <code>Float64(x::T)</code> will first be called before serializing the resulting <code>Float64</code> value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL432-L450">source</a></section></article><h4 id="StructTypes.BoolType"><a class="docs-heading-anchor" href="#StructTypes.BoolType"><code>StructTypes.BoolType</code></a><a id="StructTypes.BoolType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.BoolType" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StructTypes.BoolType" href="#StructTypes.BoolType"><code>StructTypes.BoolType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.BoolType()</code></pre><p>Declare that <code>T</code> should map to a boolean value.</p><p>Types already declared as <code>StructTypes.BoolType()</code> include:</p><ul><li><code>Bool</code></li></ul><p>The interface to satisfy for deserializing is:</p><ul><li><code>T(x::Bool)</code>: define a constructor that takes a single <code>Bool</code> value</li><li><code>StructTypes.construct(::Type{T}, x::Bool; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code></li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>Bool(x::T)</code>: define a conversion to <code>Bool</code> method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL457-L471">source</a></section></article><h4 id="StructTypes.NullType"><a class="docs-heading-anchor" href="#StructTypes.NullType"><code>StructTypes.NullType</code></a><a id="StructTypes.NullType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.NullType" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StructTypes.NullType" href="#StructTypes.NullType"><code>StructTypes.NullType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.NullType()</code></pre><p>Declare that <code>T</code> should map to a &quot;null&quot; value.</p><p>Types already declared as <code>StructTypes.NullType()</code> include:</p><ul><li><code>nothing</code></li><li><code>missing</code></li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>T()</code>: an empty constructor for <code>T</code></li><li><code>StructTypes.construct(::Type{T}, x::Nothing; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code></li></ul><p>There is no interface for serializing; if a custom type is declared as <code>StructTypes.NullType()</code>, then serializing will be handled specially; writing <code>null</code> in JSON, <code>NULL</code> in SQL, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL476-L490">source</a></section></article><h3 id="CustomStruct"><a class="docs-heading-anchor" href="#CustomStruct">CustomStruct</a><a id="CustomStruct-1"></a><a class="docs-heading-anchor-permalink" href="#CustomStruct" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StructTypes.CustomStruct" href="#StructTypes.CustomStruct"><code>StructTypes.CustomStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.CustomStruct()</code></pre><p>Signal that <code>T</code> has a custom serialization/deserialization pattern that doesn&#39;t quite fit <code>StructTypes.DataType</code> or <code>StructTypes.InterfaceType</code>. One common example are wrapper types, where you want to serialize as the wrapped type and can reconstruct <code>T</code> manually from deserialized fields directly. Defining <code>CustomStruct()</code> requires overloading <code>StructTypes.lower(x::T)</code>, which should return any serializable object, and optionally overload <code>StructTypes.lowertype(::Type{T})</code>, which returns the type of the lowered object (it returns <code>Any</code> by default). <code>lowertype</code> is used to deserialize an object, which is then passed to <code>StructTypes.construct(T, obj)</code> for construction (which defaults to calling <code>T(obj)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.lower" href="#StructTypes.lower"><code>StructTypes.lower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.lower(x::T)</code></pre><p>&quot;Unwrap&quot; or otherwise transform <code>x</code> to another object that has a well-defined <code>StructType</code> definition. This is a required method for types declaring <code>StructTypes.CustomStruct</code>. Allows objects of type <code>T</code> to conveniently serialize/deserialize as another type, when their own structure/definition isn&#39;t significant. Useful for wrapper types. See also <a href="#StructTypes.CustomStruct"><code>StructTypes.CustomStruct</code></a> and <a href="@ref"><code>StructType.lowertype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.lowertype" href="#StructTypes.lowertype"><code>StructTypes.lowertype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.lowertype(::Type{T})</code></pre><p>For <code>StructTypes.CustomStruct</code> types, they may optionally define <code>lowertype</code> to provide a &quot;deserialization&quot; type, which defaults to <code>Any</code>. When deserializing a type <code>T</code>, the deserializer will first call <code>StructTypes.lowertype(T) = S</code> and proceed with deserializing the type <code>S</code> that was returned. Once <code>S</code> has been deserialized, the deserializer will call <code>StructTypes.construct(T, x::S)</code>. With the default of <code>Any</code>, deserializers should return an <code>AbstractDict</code> object where key/values can be enumerated/checked/retrieved to make it decently convenient for <code>CustomStruct</code>s to construct themselves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL39-L49">source</a></section></article><h3 id="AbstractTypes"><a class="docs-heading-anchor" href="#AbstractTypes">AbstractTypes</a><a id="AbstractTypes-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractTypes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StructTypes.AbstractType" href="#StructTypes.AbstractType"><code>StructTypes.AbstractType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.AbstractType()</code></pre><p>Signal that <code>T</code> is an abstract type, and when deserializing, one of its concrete subtypes will be materialized, based on a &quot;type&quot; key/field in the serialization object.</p><p>Thus, <code>StructTypes.AbstractType</code>s <em>must</em> define <code>StructTypes.subtypes</code>, which should be a NamedTuple with subtype keys mapping to concrete Julia subtype values. You may optionally define <code>StructTypes.subtypekey</code> that indicates which input key/field name should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this <code>StructType</code>:</p><pre><code class="language-julia">abstract type Vehicle end

struct Car &lt;: Vehicle
    type::String
    make::String
    model::String
    seatingCapacity::Int
    topSpeed::Float64
end

struct Truck &lt;: Vehicle
    type::String
    make::String
    model::String
    payloadCapacity::Float64
end

StructTypes.StructType(::Type{Vehicle}) = StructTypes.AbstractType()
StructTypes.StructType(::Type{Car}) = StructTypes.Struct()
StructTypes.StructType(::Type{Truck}) = StructTypes.Struct()
StructTypes.subtypekey(::Type{Vehicle}) = :type
StructTypes.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)

# example from StructTypes deserialization
car = StructTypes.read(&quot;&quot;&quot;
{
    &quot;type&quot;: &quot;car&quot;,
    &quot;make&quot;: &quot;Mercedes-Benz&quot;,
    &quot;model&quot;: &quot;S500&quot;,
    &quot;seatingCapacity&quot;: 5,
    &quot;topSpeed&quot;: 250.1
}&quot;&quot;&quot;, Vehicle)</code></pre><p>Here we have a <code>Vehicle</code> type that is defined as a <code>StructTypes.AbstractType()</code>. We also have two concrete subtypes, <code>Car</code> and <code>Truck</code>. In addition to the <code>StructType</code> definition, we also define <code>StructTypes.subtypekey(::Type{Vehicle}) = :type</code>, which signals that when deserializing, when it encounters the <code>type</code> key, it should use the <strong>value</strong>, in the above example: <code>car</code>, to discover the appropriate concrete subtype to parse the structure as, in this case <code>Car</code>. The mapping of subtype key value to concrete Julia subtype is defined in our example via <code>StructTypes.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)</code>. Thus, <code>StructTypes.AbstractType</code> is useful when the object to deserialize includes a &quot;subtype&quot; key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a <code>Car</code> instead of a <code>Truck</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL497-L548">source</a></section></article><h3 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h3><p>Several utility functions are provided for fellow package authors wishing to utilize the <code>StructTypes.StructType</code> trait to integrate in their package. Due to the complexity of correctly handling the various configuration options with <code>StructTypes.Mutable</code> and some of the interface types, it&#39;s strongly recommended to rely on these utility functions and open issues for concerns or missing functionality.</p><article class="docstring"><header><a class="docstring-binding" id="StructTypes.constructfrom" href="#StructTypes.constructfrom"><code>StructTypes.constructfrom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.constructfrom(T, obj)
StructTypes.constructfrom!(x::T, obj)</code></pre><p>Construct an object of type <code>T</code> (<code>StructTypes.construtfrom</code>) or populate an existing object of type <code>T</code> (<code>StructTypes.constructfrom!</code>) from another object <code>obj</code>. Utilizes and respects StructTypes.jl package properties, querying the <code>StructType</code> of <code>T</code> and respecting various serialization/deserialization names, keyword args, etc.</p><p>Most typical use-case is construct a custom type <code>T</code> from an <code>obj::AbstractDict</code>, but <code>constructfrom</code> is fully generic, so the inverse is also supported (turning any custom struct into an <code>AbstractDict</code>). For example, an external service may be providing JSON data with an evolving schema; as opposed to trying a strict &quot;typed parsing&quot; like <code>JSON3.read(json, T)</code>, it may be preferrable to setup a local custom struct with just the desired properties and call <code>StructTypes.constructfrom(T, JSON3.read(json))</code>. This would first do a generic parse of the JSON data into a <code>JSON3.Object</code>, which is an <code>AbstractDict</code>, which is then used as a &quot;property source&quot; to populate the fields of our custom type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL875-L893">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.construct" href="#StructTypes.construct"><code>StructTypes.construct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.construct(T, args...; kw...)</code></pre><p>Function that custom types can overload for their <code>T</code> to construct an instance, given <code>args...</code> and <code>kw...</code>. The default definition is <code>StructTypes.construct(T, args...; kw...) = T(args...; kw...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL297-L302">source</a></section><section><div><pre><code class="language-none">StructTypes.construct(f, T) =&gt; T</code></pre><p>Apply function <code>f(i, name, FT)</code> over each field index <code>i</code>, field name <code>name</code>, and field type <code>FT</code> of type <code>T</code>, passing the function results to <code>T</code> for construction, like <code>T(x_1, x_2, ...)</code>. Note that any <code>StructTypes.names</code> mappings are applied, as well as field-specific keyword arguments via <code>StructTypes.keywordargs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL558-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.foreachfield" href="#StructTypes.foreachfield"><code>StructTypes.foreachfield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.foreachfield(f, x::T) =&gt; Nothing</code></pre><p>Apply function <code>f(i, name, FT, v; kw...)</code> over each field index <code>i</code>, field name <code>name</code>, field type <code>FT</code>, field value <code>v</code>, and any <code>kw</code> keyword arguments defined in <code>StructTypes.keywordargs</code> for <code>name</code> in <code>x</code>. Nothing is returned and results from <code>f</code> are ignored. Similar to <code>Base.foreach</code> over collections.</p><p>Various &quot;configurations&quot; are respected when applying <code>f</code> to each field:</p><ul><li>If keyword arguments have been defined for a field via <code>StructTypes.keywordargs</code>, they will be passed like <code>f(i, name, FT, v; kw...)</code></li><li>If <code>StructTypes.names</code> has been defined, <code>name</code> will be the serialization name instead of the defined julia field name</li><li>If a field is undefined or empty and <code>StructTypes.omitempties</code> is defined, <code>f</code> won&#39;t be applied to that field</li><li>If a field has been excluded via <code>StructTypes.excludes</code>, it will be skipped</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL605-L617">source</a></section><section><div><pre><code class="language-none">StructTypes.foreachfield(f, T) =&gt; Nothing</code></pre><p>Apply function <code>f(i, name, FT; kw...)</code> over each field index <code>i</code>, field name <code>name</code>, field type <code>FT</code>,  and any <code>kw</code> keyword arguments defined in <code>StructTypes.keywordargs</code> for <code>name</code> on type <code>T</code>. Nothing is returned and results from <code>f</code> are ignored. Similar to <code>Base.foreach</code> over collections.</p><p>Various &quot;configurations&quot; are respected when applying <code>f</code> to each field:</p><ul><li>If keyword arguments have been defined for a field via <code>StructTypes.keywordargs</code>, they will be passed like <code>f(i, name, FT, v; kw...)</code></li><li>If <code>StructTypes.names</code> has been defined, <code>name</code> will be the serialization name instead of the defined julia field name</li><li>If a field is undefined or empty and <code>StructTypes.omitempties</code> is defined, <code>f</code> won&#39;t be applied to that field</li><li>If a field has been excluded via <code>StructTypes.excludes</code>, it will be skipped</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL659-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.mapfields!" href="#StructTypes.mapfields!"><code>StructTypes.mapfields!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.mapfields!(f, x::T)</code></pre><p>Applys the function <code>f(i, name, FT; kw...)</code> to each field index <code>i</code>, field name <code>name</code>, field type <code>FT</code>, and any <code>kw</code> defined in <code>StructTypes.keywordargs</code> for <code>name</code> of <code>x</code>, and calls <code>setfield!(x, name, y)</code> where <code>y</code> is returned from <code>f</code>.</p><p>This is a convenience function for working with <code>StructTypes.Mutable</code>, where a function can be applied over the fields of the mutable struct to set each field value. It respects the various StructTypes configurations in terms of skipping/naming/passing keyword arguments as defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL707-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.applyfield!" href="#StructTypes.applyfield!"><code>StructTypes.applyfield!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.applyfield!(f, x::T, nm::Symbol) =&gt; Bool</code></pre><p>Convenience function for working with a <code>StructTypes.Mutable</code> object. For a given serialization name <code>nm</code>, apply the function <code>f(i, name, FT; kw...)</code> to the field index <code>i</code>, field name <code>name</code>, field type <code>FT</code>, and any keyword arguments <code>kw</code> defined in <code>StructTypes.keywordargs</code>, setting the field value to the return value of <code>f</code>. Various StructType configurations are respected like keyword arguments, names, and exclusions. <code>applyfield!</code> returns whether <code>f</code> was executed or not; if <code>nm</code> isn&#39;t a valid field name on <code>x</code>, <code>false</code> will be returned (important for applications where the input still needs to consume the field, like json parsing). Note that the input <code>nm</code> is treated as the serialization name, so any <code>StructTypes.names</code> mappings will be applied, and the function will be passed the Julia field name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL752-L763">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StructTypes.applyfield" href="#StructTypes.applyfield"><code>StructTypes.applyfield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">StructTypes.applyfield(f, ::Type{T}, nm::Symbol) =&gt; Bool</code></pre><p>Convenience function for working with a <code>StructTypes.Mutable</code> object. For a given serialization name <code>nm</code>, apply the function <code>f(i, name, FT; kw...)</code> to the field index <code>i</code>, field name <code>name</code>, field type <code>FT</code>, and any keyword arguments <code>kw</code> defined in <code>StructTypes.keywordargs</code>. Various StructType configurations are respected like keyword arguments, names, and exclusions. <code>applyfield</code> returns whether <code>f</code> was executed or not; if <code>nm</code> isn&#39;t a valid field name on <code>x</code>, <code>false</code> will be returned (important for applications where the input still needs to consume the field, like json parsing). Note that the input <code>nm</code> is treated as the serialization name, so any <code>StructTypes.names</code> mappings will be applied, and the function will be passed the Julia field name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/ca66c55aa4b7fa24ff7bf009d136be5809d2f375/src/StructTypes.jl#LL803-L814">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 22 March 2021 00:02">Monday 22 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
